use std::ops::Range;

use crate::surface::{Term, Literal};

grammar;

pub Term: Term<&'input str> = {
    ExprTerm,
    <term: ExprTerm> ":" <ty: Term> => Term::Ann(Box::new(term), Box::new(ty)),
};

ExprTerm: Term<&'input str> = {
    ArrowTerm,
    <start: @L> "fun" <param_names: ParamName+> "=>" <body: ExprTerm> => {
        Term::FunctionTerm(start.., param_names, Box::new(body))
    },
};

ArrowTerm: Term<&'input str> = {
    AppTerm,
    <start: @L> "Fun" <param_type_groups: ("(" <ParamName+> ":" <AppTerm> ")")+>
        "->" <body_type: ArrowTerm> =>
    {
        Term::FunctionType(start.., param_type_groups, Box::new(body_type))
    },
    <param_type: AppTerm> "->" <body_type: ArrowTerm> => {
        Term::FunctionArrowType(Box::new(param_type), Box::new(body_type))
    },
};

AppTerm: Term<&'input str> = {
    AtomicTerm,
    <head: AtomicTerm> <arguments: AtomicTerm+> => {
        Term::FunctionElim(Box::new(head), arguments)
    },
};

AtomicTerm: Term<&'input str> = {
    "(" <term: Term> ")" => term,
    <start: @L> <name: Name> <end: @R> => Term::Name(start..end, name),
    <start: @L> <literal: Literal> <end: @R> => Term::Literal(start..end, literal),
    <start: @L> "[" <entries: List<Term>> "]" <end: @R> => Term::Sequence(start..end, entries),
    <start: @L> "Record" "{" <entries: List<TypeEntry>> "}" <end: @R> => Term::RecordType(start..end, entries),
    <start: @L> "record" "{" <entries: List<TermEntry>> "}" <end: @R> => Term::RecordTerm(start..end, entries),
    <head: AtomicTerm> "." <name_start: @L> <name: Name> <end: @R> => Term::RecordElim(Box::new(head), name_start..end, name),
    <start: @L> <term: AtomicTerm> <shift: r"\^[0-9]+(\.[0-9]+)?"> <end: @R> => {
        Term::Lift(start..end, Box::new(term), shift[1..].parse().unwrap()) // FIXME: Overflow!
    },
};

List<Entry>: Vec<Entry> = {
    <mut entries: (<Entry> ",")*> <last: Entry?> => {
        entries.extend(last);
        entries
    }
}

TypeEntry: (Range<usize>, &'input str, Term<&'input str>) = {
    <start: @L> <name: Name> <end: @R> ":" <term: Term> => (start..end, name, term),
};

TermEntry: (Range<usize>, &'input str, Term<&'input str>) = {
    <start: @L> <name: Name> <end: @R> "=" <term: Term> => (start..end, name, term),
};

ParamName: (Range<usize>,&'input str) = {
    <start: @L> <name: Name> <end: @R> => (start..end, name),
};

Name: &'input str = {
    r"[a-zA-Z][a-zA-Z0-9\-]*" => <>,
};

Literal: Literal<&'input str> = {
    r#"'(.|\\"|\\')*'"# => Literal::Char(<>),
    r#""(.|\\"|\\')*""# => Literal::String(<>),
    r"[-+]?[0-9]+(\.[0-9]+)?" => Literal::Number(<>),
};
