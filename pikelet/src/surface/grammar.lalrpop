use std::ops::Range;

use crate::surface::{Literal, MetaData, Term};
use crate::surface::lexer::{LexerError, Token};

grammar<'input>;

extern {
    type Location = usize;
    type Error = LexerError;

    enum Token<'input> {
        "->"  => Token::Arrow,
        "=>"  => Token::DArrow,
        ":"   => Token::Colon,
        ","   => Token::Comma,
        "."   => Token::Dot,
        "fun" => Token::FunTerm,
        "record" => Token::RecordTerm,
        "Record" => Token::RecordType,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBrack,
        "]" => Token::RBrack,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "=" => Token::Equal,
        CharLiteral => Token::CharLiteral(<&'input str>),
        StrLiteral => Token::StrLiteral(<&'input str>),
        NumLiteral => Token::NumLiteral(<&'input  str>),
        Id => Token::Name(<&'input str>),
        Shift => Token::Shift(<&'input str>),
        DocComment => Token::DocComment(<&'input str>),
    }
}

// Doesn't get used yet.
DocComments<S>: Vec<S> = {
  <doc_comments: DocComments<S>*> <doc_comment: DocComment?> => {
     match doc_comment {
       None => doc_comments,
       Some(doc_comment) => {
	     let mut doc_comments = doc_comments;
	     doc_comments.push(doc_comment)
       },
     }
  }
}

pub Term: Term<&'input str> = {
    <start: @L> <doc_comment: DocComment?> <end: @R> <term: ExprTerm> => {
	match doc_comment {
	      None => term,
	      Some(data) => {
	        let comment_meta = MetaData::DocComment(start..end, data);
	        Term::Meta(comment_meta, Box::new(term))
	      }
       }
    },
    <start: @L> <doc_comment: DocComment?> <end: @R> <term: ExprTerm> ":" <ty: Term> => {
       let typed_term = Term::Ann(Box::new(term), Box::new(ty));
       match doc_comment {
         None => typed_term,
         Some(data) => {
		let comment_term = MetaData::DocComment(start..end, data);
		Term::Meta(comment_term, Box::new(typed_term))
	 }
      }
   },
};

ExprTerm: Term<&'input str> = {
    ArrowTerm,
    <start: @L> "fun" <param_names: ParamName+> "=>" <body: ExprTerm> => {
        Term::FunctionTerm(start.., param_names, Box::new(body))
    },
};

ArrowTerm: Term<&'input str> = {
    AppTerm,
    <param_type: AppTerm> "->" <body_type: ArrowTerm> => {
        Term::FunctionType(Box::new(param_type), Box::new(body_type))
    },
};

AppTerm: Term<&'input str> = {
    AtomicTerm,
    <head: AtomicTerm> <arguments: AtomicTerm+> => {
        Term::FunctionElim(Box::new(head), arguments)
    },
};

AtomicTerm: Term<&'input str> = {
    "(" <term: Term> ")" => term,
    <start: @L> <name: Name> <end: @R> => Term::Name(start..end, name),
    <start: @L> <literal: Literal> <end: @R> => Term::Literal(start..end, literal),
    <start: @L> "[" <entries: List<Term>> "]" <end: @R> => Term::Sequence(start..end, entries),
    <start: @L> "Record" "{" <entries: List<TypeEntry>> "}" <end: @R> => Term::RecordType(start..end, entries),
    <start: @L> "record" "{" <entries: List<TermEntry>> "}" <end: @R> => Term::RecordTerm(start..end, entries),
    <head: AtomicTerm> "." <name_start: @L> <name: Name> <end: @R> => Term::RecordElim(Box::new(head), name_start..end, name),
    <start: @L> <term: AtomicTerm> <shift:Shift> <end: @R> => {
        Term::Lift(start..end, Box::new(term), shift[1..].parse().unwrap()) // FIXME: Overflow!
    },
};

List<Entry>: Vec<Entry> = {
    <mut entries: (<Entry> ",")*> <last: Entry?> => {
        entries.extend(last);
        entries
    }
}

TypeEntry: (Range<usize>, &'input str, Term<&'input str>) = {
    <start: @L> <name: Name> <end: @R> ":" <term: Term> => (start..end, name, term),
};

TermEntry: (Range<usize>, &'input str, Term<&'input str>) = {
    <start: @L> <name: Name> <end: @R> "=" <term: Term> => (start..end, name, term),
};

ParamName: (Range<usize>,&'input str) = {
    <start: @L> <name: Name> <end: @R> => (start..end, name),
};

Name: &'input str = {
    Id,
};

Literal: Literal<&'input str> = {
    CharLiteral => Literal::Char(<>),
    StrLiteral => Literal::String(<>),
    NumLiteral => Literal::Number(<>),
};
